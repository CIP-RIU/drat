{
    "collab_server" : "",
    "contents" : "##' R can use multiple archives: CRAN, BioConductor and Omegahat have\n##' been supported for years.  It is equally easy to add local\n##' archives from the same machine, or local network, or university /\n##' company network as well as other publically available\n##' repositories.  This function aids in the process, and defaults to\n##' inserting a given source archive into a given repository.\n##'\n##' This function inserts the given (source or binary) package file\n##' into the given (local) package repository and updates the\n##' index. By setting the \\code{commit} option to \\code{TRUE}, one can\n##' then push to a remote git code repository. If the\n##' \\code{\\link[git2r]{git2r}} package is installed, it is used for\n##' the interaction with the git repository; otherwise the \\code{git}\n##' shell command is used.\n##'\n##' An aliased function \\code{insert} is also available, but not\n##' exported via \\code{NAMESPACE} to not clobber a possibly unrelated\n##' function; use it via \\code{drat:::insert()}.\n##' @title Insert a package source or binary file into a drat repository\n##' @aliases drat:::insert\n##' @param file An R package in source or binary format,\n##' @param repodir A local directory corresponding to the repository\n##' top-level directory.\n##' @param commit Either boolean toggle to select automatic git operations\n##' \\sQuote{add}, \\sQuote{commit}, and \\sQuote{push} or, alternatively,\n##' a character variable can be used to specify a commit message; this also\n##' implies the \\sQuote{TRUE} values in other contexts.\n##' @param pullfirst Boolean toggle to call \\code{git pull} before inserting the package. \n##' @param action A character string containing one of: \\dQuote{none} \n##' (the default; add the new package into the repo, effectively masking \n##' previous versions), \\dQuote{archive} (place any previous versions into \n##' a package-specific archive folder, creating such an archive if it does \n##' not already exist), or \\dQuote{prune} (calling \\code{\\link{pruneRepo}}).\n##' @param ... For \\code{insert} the aliases variant, a catch-all collection of\n##' parameters. For \\code{insertPackage} arguments passed to \\code{write_PACKAGES}.\n##' @return NULL is returned.\n##' @examples\n##' \\dontrun{\n##'   insertPackage(\"foo_0.2.3.tar.gz\")   # inserts into (default) repo\n##'   insertPackage(\"foo_0.2.3.tar.gz\", \"/nas/R/\")  # ... into local dir\n##' }\n##' \\dontrun{\n##'   insertPackage(\"foo_0.2.3.tar.gz\", action = \"prune\")   # prunes any older copies\n##'   insertPackage(\"foo_0.2.3.tar.gz\", action = \"archive\")   # archives any older copies\n##' }\n##' @author Dirk Eddelbuettel\ninsertPackage <- function(file,\n                          repodir=getOption(\"dratRepo\", \"~/git/drat\"),\n                          commit=FALSE,\n                          pullfirst=FALSE,\n                          action=c(\"none\", \"archive\", \"prune\"),\n                          ...) {\n\n    if (!file.exists(file)) stop(\"File \", file, \" not found\\n\", call.=FALSE)\n\n    ## TODO src/contrib if needed, preferably via git2r\n    if (!dir.exists(repodir)) stop(\"Directory \", repodir, \" not found\\n\", call.=FALSE)\n\n    ## check for the optional git2r package\n    haspkg <- requireNamespace(\"git2r\", quietly=TRUE)\n    hascmd <- length(Sys.which(\"git\")) > 0\n\n    curwd <- getwd()\n    on.exit(setwd(curwd))               # restore current working directory \n\n    pkg <- basename(file)\n    msg <- if (isTRUE(commit)) sprintf(\"Adding %s to drat\", pkg) else \"\"\n    ## special case of commit via message: not TRUE, and character \n    if (!isTRUE(commit) && typeof(commit) == \"character\" && nchar(commit) > 0) {\n        msg <- commit\n        commit <- TRUE\n    }\n    \n    if (commit && haspkg) {  \n        repo <- git2r::repository(repodir)\n        if (isTRUE(pullfirst)) git2r::pull(repo)\n        git2r::checkout(repo, \"gh-pages\")\n    } else if (commit && hascmd) {\n        setwd(repodir)\n        if (isTRUE(pullfirst)) system(\"git pull\")\n        system(\"git checkout gh-pages\")\n        setwd(curwd)\n    }\n\n    pkgtype <- identifyPackageType(file)\n    reldir <- getPathForPackage(file)\n\n    pkgdir <- file.path(repodir, reldir)\n\n    if (!file.exists(pkgdir)) {\n        ## TODO: this could be in a git branch, need checking\n        if (!dir.create(pkgdir, recursive = TRUE)) {\n            stop(\"Directory \", pkgdir, \" couldn't be created\\n\", call.=FALSE)\n        }\n    }\n\n    ## copy file into repo\n    if (!file.copy(file, pkgdir, overwrite=TRUE)) {\n        stop(\"File \", file, \" can not be copied to \", pkgdir, call.=FALSE)\n    }\n    \n    ## update index\n    write_PACKAGES(pkgdir, type=pkgtype, ...)\n\n    if (commit) {\n        if (haspkg) {\n            repo <- git2r::repository(repodir)\n            setwd(pkgdir)\n            git2r::add(repo, file.path(reldir, pkg))\n            git2r::add(repo, file.path(reldir, \"PACKAGES\"))\n            git2r::add(repo, file.path(reldir, \"PACKAGES.gz\"))\n            tryCatch(git2r::commit(repo, msg), error = function(e) warning(e))\n            #TODO: authentication woes?   git2r::push(repo)  \n            message(\"Added and committed \", pkg, \" plus PACKAGES files. Still need to push.\\n\") \n        } else if (hascmd) {\n            setwd(pkgdir)\n            cmd <- sprintf(paste(\"git add %s PACKAGES PACKAGES.gz;\",\n                                 \"git commit -m\\\"%s\\\";\",\n                                 \"git push\"), pkg, msg)\n            system(cmd) ## TODO: error checking\n            message(\"Added, committed and pushed \", pkg, \" plus PACKAGES files.\\n\") \n        } else {\n            warning(\"Commit skipped as both git2r package and git command missing.\",\n                    call.=FALSE)\n        }\n    }\n    \n    action <- match.arg(action)\n    pkgname <- gsub(\"\\\\.tar\\\\..*$\", \"\", pkg)\n    pkgname <- strsplit(pkgname, \"_\", fixed=TRUE)[[1L]][1L]\n    if (action == \"prune\") {\n        pruneRepo(repopath = repodir, pkg = pkgname, remove = TRUE)\n    } else if (action == \"archive\") {\n        archivePackages(repopath = repodir, pkg = pkgname)\n    }\n    \n    invisible(NULL)\n}\n\n\n    \n##' @rdname insertPackage\ninsert <- function(...) insertPackage(...)\n\n\n##' This function identifies the package type from a filename.\n##'\n##' The returned string is suitable for \\code{write_PACKAGES()}.\n##' @title Identifies the package type from a filename\n##' @param file An R package in source or binary format,\n##' @return string Type of the supplied package.\n##' @author Jan Schulz and Dirk Eddelbuettel\nidentifyPackageType <- function(file) {\n    ##from src/library/tools/R/packages.R\n    ret <- if (grepl(\"_.*\\\\.tar\\\\..*$\", file)) {\n        \"source\"\n    } else if (grepl(\"_.*\\\\.tgz$\", file)) {\n        \"mac.binary\"\n    } else if (grepl(\"_.*\\\\.zip$\", file)) {\n        \"win.binary\"\n    } else {\n        stop(\"Unknown package type\", call.=FALSE)\n    }\n    return(ret)\n}\n\n##' This function returns the compile-time information added\n##' to the \\code{DESCRIPTION} file in the package.\n##'\n##' @title Get information from a binary package \n##' @param file the fully qualified path of the package\n##' @return A named vector with several components\n##' @author Dirk Eddelbuettel\ngetPackageInfo <- function(file) {\n    if (!file.exists(file)) stop(\"File \", file, \" not found!\", call.=FALSE)\n    \n    td <- tempdir()\n    if (grepl(\".zip$\", file)) {\n        unzip(file, exdir=td)\n    } else if (grepl(\".tgz$\", file)) {\n        untar(file, exdir=td)\n    } else {\n        ##stop(\"Not sure we can handle \", file, call.=FALSE)\n        fields <- c(\"Source\"=TRUE, \"Rmajor\"=NA, \"Mavericks\"=FALSE)\n        return(fields)\n    }\n\n    pkgname <- gsub(\"^([a-zA-Z0-9.]*)_.*\", \"\\\\1\", basename(file))\n    path <- file.path(td, pkgname, \"DESCRIPTION\")\n    builtstring <- read.dcf(path, 'Built')\n    unlink(file.path(td, pkgname), recursive=TRUE)\n\n    fields <- strsplit(builtstring, \"; \")[[1]]\n    names(fields) <- c(\"Rversion\", \"OSflavour\", \"Date\", \"OS\")\n\n    rmajor <- gsub(\"^R (\\\\d\\\\.\\\\d)\\\\.\\\\d.*\", \"\\\\1\", fields[\"Rversion\"])\n    isDarwin13 <- ifelse(fields[\"OSflavour\"] == \"x86_64-apple-darwin13.4.0\", \"yes\", \"no\")\n    fields <- c(fields, \"Rmajor\"=unname(rmajor), \"Mavericks\"=unname(isDarwin13))\n\n    return(fields)\n}\n\n##' This function returns the directory path (relative to \n##' the repo root) where the package needs to be copied to.\n##'\n##' @title Get relative path for package type\n##' @param file The fully qualified path of the package\n##' @return string Relative file path where packages of \n##' this type should be copied to.\n##' @author Jan Schulz, Dirk Eddelbuettel and Matthew Jones\ngetPathForPackage <- function(file) {\n    pkgtype <- identifyPackageType(file)\n    fields <- getPackageInfo(file)\n    rversion <- unname(fields[\"Rmajor\"])\n        \n    if (pkgtype == \"source\") {\n        ret <- file.path(\"src\", \"contrib\")\n    } else if (pkgtype == \"win.binary\") {\n        ret <- file.path(\"bin\", \"windows\", \"contrib\", rversion)\n    } else if (pkgtype == \"mac.binary\") {\n        if (fields[\"OSflavour\"] == \"\") {\n            # non-binary package, treated as Mavericks\n            message(\"Note: Non-binary OS X package will be installed in Mavericks path.\")\n            fields[\"Mavericks\"] <- \"yes\"\n        }\n        if (unname(fields[\"Mavericks\"]) == \"yes\") {\n            ret <- file.path(\"bin\", \"macosx\", \"mavericks\", \"contrib\", rversion)\n        } else {\n            ret <- file.path(\"bin\", \"macosx\", \"contrib\", rversion)\n        }\n    }\n    return(ret)\n}\n\n\n\n",
    "created" : 1497282940779.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3364792674",
    "id" : "787CCF04",
    "lastKnownWriteTime" : 1497282900,
    "last_content_update" : 1497282900,
    "path" : "D:/HIDAP_PACAKGES/Hidap_repository_cloud/git/drat/R/insertPackage.R",
    "project_path" : "R/insertPackage.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}